<!DOCTYPE html>
<html>
	<head>
		<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
		<title>Ruby on Rails 實戰聖經 | Ruby 程式語言入門</title>
		<link rel="stylesheet" type="text/css" href="./style.css">
		<link rel="canonical" href="https://ihower.tw/rails4/ruby.html">
	</head>
<body>
<div class="container">
    <div class="page_header">
        <h1 class="logo"><a href="./index.html">Ruby on Rails 實戰聖經<span>使用 Rails 4.2 及 Ruby 2.1</span></a></h1>
        <div class="search_box">
            <form class="search" action="https://www.google.com/search">
            <input type="hidden" value="ihower.tw/rails4" name="as_sitesearch">
            <input class="search_field" type="text" value="" name="as_q">
            <input class="search_btn" type="submit" value="Search">
            </form>
        </div>
    </div>

    <div class="notice">
    <p class="inner info_bubble">
      <a href="https://leanpub.com/ihower-rails-book">電子書</a>和簡體版本準備中。如果您有任何意見、鼓勵或勘誤，歡迎<a href="mailto:ihower@gmail.com">來信給我</a>，謝謝。
    </p>
    </div>

    <div class="inner wrap">
       <div class="sidebar">
            <h3><a href="about.html">關於本書</a></h3>
            <h3><a href="index.html">回首頁</a></h3>
       </div>
       <div class="content body">
	      <h1 id="ruby-">Ruby 程式語言入門</h1>

<blockquote>
  <p>Actually, I’m trying to make Ruby natural, not simple. Ruby is simple in appearance, but is very complex inside, just like our human body. - Matz, Ruby 發明人</p>
</blockquote>

<p><em>Ruby</em>是個美麗、靈巧而且方便又實用的程式語言，而<em>Ruby on Rails</em>正是 Ruby 程式語言爆發成長的催化劑。在了解<em>Ruby on Rails</em>的程式之前，學習<em>Ruby</em>程式語言是最重要的基礎功課之一，我們在這一章節將快速帶過一些基本的語法，網路上也有<em>Ruby Taiwan</em>社群所翻譯的文章可以一讀：</p>

<ul>
  <li>
<em>Ruby</em>中文官方網站：<a href="http://www.ruby-lang.org/zh_TW/about/">Ruby簡介</a>
</li>
  <li>
<em>Ruby</em>中文官方網站：<a href="http://www.ruby-lang.org/zh_TW/documentation/quickstart/">二十分鐘Ruby體驗</a>
</li>
  <li>
<em>Ruby</em>中文官方網站：<a href="http://www.ruby-lang.org/zh_TW/documentation/ruby-from-other-languages/">從其他程式語言到Ruby</a>
</li>
  <li><a href="http://guides.ruby.tw/ruby/">Ruby使用手冊</a></li>
</ul>

<p>免費的英文資源也很多，我推薦以下三個教學網站作為練習之用：</p>

<ul>
  <li>
<a href="http://www.gotealeaf.com/books/ruby">Introduction to Programming with Ruby by Tealeaf Academy</a> 除了入門的內容，還包括完整練習題和解答</li>
  <li>
<a href="http://ruby.learncodethehardway.org/book/">Learn Ruby the Hard Way</a> 以習題為主的教材</li>
  <li>
<a href="http://www.codecademy.com/en/tracks/ruby">Codecademy</a> 從做中學的線上互動教學</li>
</ul>

<h2 id="ruby">各種<em>Ruby</em>實作</h2>

<p>除了用<em>C</em>語言實作的官方版本<a href="http://ruby-lang.org/"><em>Ruby</em></a>(又叫做<em>CRuby</em>或<em>MRI, Matz’s Ruby Interpreter</em>)，也有其他不同實作的<em>Ruby</em>環境。這些實作都以<em><a href="http://rubyspec.org/">RubySpec</a></em>作為其語法的標準：</p>

<ul>
  <li>
<em><a href="http://jruby.org/">JRuby</a></em>是由<em>Java</em>實作的<em>Ruby</em>，運行在高效能、支援系統執行緒及有非常多函數庫的<em>Java</em>虛擬機器<em>(JVM)</em>上。<em>JRuby</em>算是目前<em>Ruby</em>要開發跨平台(<em>Windows</em>、<em>Mac</em>和<em>Linux</em>)桌面軟體最好的選擇。</li>
  <li>
<em><a href="http://rubini.us/">Rubinuis</a></em>是用<em>C++</em>、<em>Ruby</em>和<em>LLVM</em>編譯器技術實作的<em>Ruby VM</em>，可以在<em>Mac OS X</em>、<em>Debian/Ubuntu</em>、<em>FreeBSD</em>、<em>Windows</em>上執行。<em>LLVM</em>可以說是當代最重要的編譯器架構，擁有各種編譯器最佳化技術。能給<em>Ruby</em>帶來多少效能改善幅度，值得關注。</li>
</ul>

<h2 id="irbinteractive-ruby"><em>IRB(Interactive Ruby)</em></h2>

<p><em>IRB</em>是一個互動的<em>Ruby</em>環境，可以讓我們練習和語法，做些簡單的實驗。請輸入<code>irb</code>就會進入互動模式：</p>

<pre><code>$ irb
irb: Interactive Ruby
irb(main):001:0&gt;
irb(main):001:0&gt; 1 + 1
=&gt; 2
</code></pre>

<p>在<code>irb</code>之中，每行執行完<em>Ruby</em>都會自動幫你<code>puts</code>輸出結果。</p>

<p>不過，一旦程式稍微複雜一點，還是打開文字編輯器吧。讓我們編輯一個檔案<em>hello.rb</em>。<em>Ruby</em>腳本附檔名的慣例是<em>.rb</em>，內容如下：</p>

<pre><code>puts "Hello, World!!"
</code></pre>

<p>存檔後，輸入：</p>

<pre><code>$ ruby hello.rb
</code></pre>

<p>就會執行這個腳本了，它會在螢幕上輸出<em>Hello, World!!</em>。</p>

<h2 id="section">程式語言分類</h2>

<p>根據需不需要事先宣告變數型別，我們可以分類出靜態分型<em>(Static typing</em>)與動態分型<em>(Dynamic typing)</em>程式語言，前者例如<em>Java</em>、<em>C</em>、<em>C++</em>，後者例如<em>Ruby</em>、<em>Perl</em>、<em>Python</em>和<em>PHP</em>。根據會不會隱性自動轉換型別，又可以區分出不會自動轉換型別的強分型<em>(Strong typing)</em>與自動轉換型別的弱分型<em>(Weak typing)</em>，前者例如<em>Ruby</em>、<em>Perl</em>、<em>Python</em>、<em>Java</em>，後者例如<em>PHP</em>、<em>C</em>、<em>C++</em>是弱分型。讓我們舉個例吧：</p>

<pre><code>/* PHP */
$i = 1;
echo "Value is " . $i ;
# Value is 1

/* C */
int a = 5;
float b = a;
</code></pre>

<p>以上的<em>PHP</em>和<em>C</em>會隱性地自動轉型，但是以下的<em>Ruby</em>程式會檢查型別不相配而發生錯誤，這一點從<em>PHP</em>過來的朋友要特別注意。</p>

<pre><code># Ruby
i = 1
puts "Value is " + i

# TypeError: can't convert Fixnum into String
#   from (irb):2:in `+'
#   from (irb):2
</code></pre>

<p>另外，通常動態分型的程式語言多半也是直譯式<em>(interpreted)</em>程式語言，也就是不需要事先編譯，透過直譯器<em>(interpreter)</em>執行即可，當然<em>Ruby</em>也不例外。相對的，編譯式<em>(compiled)</em>語言則是事先編譯成執行檔才行執行。總結以上，<em>Ruby</em>是個動態強分型的直譯式程式語言。</p>

<h2 id="integer">整數<em>Integer</em>
</h2>

<p>任何整數都是<em>Fixnum</em>物件：</p>

<pre><code>5
-205
9999999999
0
</code></pre>

<p>完整的<em>Fixnum API</em>請參考<em><a href="http://www.ruby-doc.org/core/classes/Fixnum.html">Ruby doc</a></em>文件。</p>

<h2 id="float">浮點數<em>Float</em>
</h2>

<p>中間帶有點號的就是浮點數<em>Float</em>物件：</p>

<pre><code>54.321
0.001
-12.312
0.0
</code></pre>

<p>浮點數四則運算範例如下：</p>

<pre><code>puts 1.0 + 2.0
puts 2.0 * 3.0
puts 5.0 - 8.0
puts 9.0 / 2.0

# 3.0
# 6.0
# -3.0
# 4.5
</code></pre>

<p>要注意的是，整數四則運算結果，也會是整數：</p>

<pre><code>puts 1 + 2
puts 2 * 3
puts 5 - 8
puts 9 / 2

# 3
# 6
# -3
# 4
</code></pre>

<p>以下是一個更複雜的四則運算例子：</p>

<pre><code>puts 5 * (12 - 8) + -15
puts 98 + (59872 / (13*8)) * -52
</code></pre>

<p>完整的<em>Float API</em>請參考<em><a href="http://www.ruby-doc.org/core/classes/Float.html">Ruby doc</a></em>文件。</p>

<h2 id="string">字串<em>String</em>
</h2>

<p>使用單引號或雙引號括起來的是字串<em>String</em>物件：</p>

<pre><code>puts 'Hello, world!'
puts ''
puts 'Good-bye.'
</code></pre>

<p>字串相加可以使用加號，要注意的是字串不能直接跟數字相加，會發生例外錯誤：</p>

<pre><code>puts 'I like ' + 'apple pie.'
puts 'You\'re smart!'

puts '12' + 12
#&lt;TypeError: can't convert Fixnum into String&gt;
</code></pre>

<p>更多字串方法示範：</p>

<pre><code>var1 = 'stop'
var2 = 'foobar'
var3 = "aAbBcC"

puts var1.reverse # pots
puts var2.length # 6
puts var3.upcase # AABBCC
puts var3.downcase # aabbcc
</code></pre>

<p>為了方便字串的組合，<em>Ruby</em>也支持內插的方式：</p>

<pre><code>verb = 'work'
where = 'office'

puts "I #{verb} at the #{where}" # 輸出 I work at the office
</code></pre>

<p>注意到使用雙引號(“)的字串才會進行內插處理。如果換成單引號(‘)：</p>

<pre><code>puts 'I #{verb} at the #{where}' # 輸出 I #{verb} at the #{where}
</code></pre>

<p>完整的<em>String API</em>請參考<em><a href="http://www.ruby-doc.org/core/classes/String.html">Ruby String API</a></em>文件。</p>

<h2 id="ruby-1">
<em>Ruby</em>完全地物件導向</h2>

<p>你可能已經注意到，在<em>Ruby</em>裡每樣東西都是物件，包括字串和數字。所有的方法都是對物件呼叫，你不會看到全域函式，例如<em>PHP</em>的<code>strlen("test")</code>用法，在<em>Ruby</em>中是<code>"test".length</code>。</p>

<pre><code># 輸出「UPPER」
puts "upper".upcase

# 輸出 -5 的絕對值
puts -5.abs

# 輸出 Fixnum 類別
puts 99.class

# 輸出五次「Ruby Rocks!」
5.times do
  puts "Ruby Rocks!"
end
</code></pre>

<h2 id="local-variable">區域變數<em>Local Variable</em>
</h2>

<p>區域變數使用小寫開頭，偏好單字之間以底線<code>_</code>來分隔。範例如下：</p>

<pre><code>composer = 'Mozart'
puts composer + ' was "da bomb", in his day.'

my_composer = 'Beethoven'
puts 'But I prefer ' + my_composer + ', personally.'
</code></pre>

<p>如果存取一個尚未初始過的區域變數，會得到以下錯誤：</p>

<pre><code>NameError: undefined local variable or method `qwer' for main:Object
from (irb):1
from /Users/ihower/.rvm/rubies/ruby-2.1.5/bin/irb:11:in `&lt;main&gt;'
</code></pre>

<h2 id="conversions">型別轉換<em>Conversions</em>
</h2>

<p>剛剛提到數字和字串物件不能直接相加，你必須使用<code>to_s</code>(轉成字串)、<code>to_i</code>(轉成整數)或<code>to_f</code>(轉成浮點數)來手動轉型，範例如下：</p>

<pre><code>var1 = 2
var2 = '5'

puts var1.to_s + var2 # 25
puts var1 + var2.to_i # 7

puts 9.to_f / 2 # 4.5
</code></pre>

<h2 id="constant">常數<em>Constant</em>
</h2>

<p>大寫開頭的是為常數，範例如下：</p>

<pre><code>Foo = 1
Foo = 2 # (irb):3: warning: already initialized constant Foo

RUBY_PLATFORM # =&gt; "x86_64-darwin10.7.0"
ENV # =&gt; { "PATH" =&gt; "....", "LC_ALL" =&gt; "zh_TW.UTF-8" }
</code></pre>

<h2 id="nil">空值<em>nil</em>
</h2>

<p>表示未設定值、未定義的狀態：</p>

<pre><code>nil # nil
nil.class # NilClass

nil.nil? # true
42.nil? # false

nil == nil # true
false == nil # false
</code></pre>

<h2 id="section-1">註解</h2>

<p><em>Ruby</em>偏好一律使用單行註解：</p>

<pre><code># this is a comment line
# this is a comment line
</code></pre>

<p>多行註解比較少見：</p>

<pre><code>=begin
    This is a comment line
    This is a comment line
=end
</code></pre>

<h2 id="symbols">字串符號<em>Symbols</em>
</h2>

<p><em>Symbol</em>是唯一且不會變動的識別名稱，用冒號開頭：</p>

<pre><code>:this_is_a_symbol
</code></pre>

<p>為什麼不就用字串呢？這是因為相同名稱的<em>Symbol</em>不會再重複建構物件，所以使用<em>Symbol</em>可以執行的更有效率。範例如下：</p>

<pre><code>puts "foobar".object_id      # 輸出 2151854740
puts "foobar".object_id      # 輸出 2151830100
puts :foobar.object_id       # 輸出 577768
puts :foobar.object_id       # 輸出 577768
</code></pre>

<p><code>object_id</code>方法會回傳<em>Ruby</em>內部的記憶體配置編號。你會發現兩個字串就算內容相同，也是不同的物件。但是<em>Symbol</em>只要內容相同，就是相同的物件。這種特性讓<em>Symbol</em>的主要用途是作為雜湊<em>Hash</em>的鍵(Key)，一會就會介紹到。</p>

<h2 id="array">陣列<em>Array</em>
</h2>

<p>使用中括號，索引從<code>0</code>開始。注意到陣列中的元素是不限同一類別，想放什麼都可以：</p>

<pre><code>a = [ 1, "cat", 3.14 ]

puts a[0] # 輸出 1
puts a.size # 輸出 3

a[2] = nil
puts a.inspect # 輸出 [1, "cat", nil]
a[99] # nil
</code></pre>

<blockquote>
  <p><code>inspect</code>方法會將物件轉成適合給人看的字串</p>
</blockquote>

<p>如果讀取一個沒有設定的陣列元素，預設值是<code>nil</code>。更多陣列方法範例：</p>

<pre><code>colors = ["red", "blue"]

colors.push("black")
colors &lt;&lt; "white"
puts colors.join(", ") # red, blue, black, white

colors.pop
puts colors.last #black
</code></pre>

<p>使用<code>each</code>方法走訪陣列：</p>

<pre><code>languages = ['Ruby', 'Javascript', 'Perl']

languages.each do |lang|
  puts 'I love ' + lang + '!'
end

# I Love Ruby!
# I Love Javascript!
# I Love Perl!
</code></pre>

<p>完整的<em>Array API</em>請參考<em>[Ruby Array API(http://www.ruby-doc.org/core/classes/Array.html)</em>文件。</p>

<h2 id="hash">雜湊<em>Hash</em>
</h2>

<p><em>Hash</em>是一種<em>鍵值對(Key-Value)</em>的資料結構，雖然你可以使用任何物件當作<em>Key</em>，但是通常我們使用<em>Symbol</em>當作<em>Key</em>。例如：</p>

<pre><code>config = { :foo =&gt; 123, :bar =&gt; 456 }
puts config[:foo] # 輸出 123
config["nothing"] # 是 nil
</code></pre>

<p>在<em>Ruby 1.9</em>後支援新的語法，比較簡約：</p>

<pre><code>config = { foo: 123, bar: 456 } # 等同於 { :foo =&gt; 123, :bar =&gt; 456 }
</code></pre>

<p>如果讀取一個不存在的值，例如上述範例的<code>nothing</code>，預設值是<code>nil</code>。</p>

<p>使用<code>each</code>方法可以走訪雜湊：</p>

<pre><code>config = { :foo =&gt; 123, :bar =&gt; 456 }
config.each do |key, value|
  puts "#{key} is #{value}"
end

# foo is 123
# bar is 456
</code></pre>

<p>完整的<em>Hash API</em>請參考<em><a href="http://www.ruby-doc.org/core/classes/Hash.html">Ruby Hash API</a></em>文件。</p>

<h2 id="flow-control">流程控制<em>Flow Control</em>
</h2>

<p>讓我們來看看一些流程控制：</p>

<h3 id="section-2">比較方法</h3>

<pre><code>puts 1 &gt; 2 # 大於
puts 1 &lt; 2 # 小於
puts 5 &gt;= 5 # 大於等於
puts 5 &lt;= 4 # 小於等於
puts 1 == 1 # 等於
puts 2 != 1 # 不等於

puts ( 2 &gt; 1 ) &amp;&amp; ( 2 &gt; 3 ) # 和
puts ( 2 &gt; 1 ) || ( 2 &gt; 3 ) # 或
</code></pre>

<h3 id="if">控制結構<em>If</em>
</h3>

<p><em>else if</em>寫成<code>elsif</code>：</p>

<pre><code>total = 26000

if total &gt; 100000
  puts "large account"
elsif total &gt; 25000
  puts "medium account"
else
  puts "small account"
end
</code></pre>

<p>另外如果要執行的<code>if</code>程式只有一行，可以將<code>if</code>放到行末即可：</p>

<pre><code>puts "greater than ten" if total &gt; 10
</code></pre>

<h3 id="section-3">三元運算子</h3>

<p>三元運算子<code>expression ? true_expresion : false_expression</code>可以讓我們處理簡易的<em>if else</em>條件，例如以下的程式：</p>

<pre><code>x = 3
if x &gt; 3
  y = "foo"
else
  y = "bar"
end
</code></pre>

<p>改用三元運算子之後，可以縮減程式行數：</p>

<pre><code>x = 3
y = ( x &gt; 3 ) ? "foo" : "bar"
</code></pre>

<h3 id="case">控制結構<em>Case</em>
</h3>

<pre><code>case name
  when "John"
    puts "Howdy John!"
  when "Ryan"
    puts "Whatz up Ryan!"
  else
    puts "Hi #{name}!"
end
</code></pre>

<h3 id="while-loop-until-next-and-break">迴圈 while, loop, until, next and break</h3>

<p><em>while</em>用法範例：</p>

<pre><code>i=0
while ( i &lt; 10 )
  i += 1
  next if i % 2 == 0 #跳過雙數
end
</code></pre>

<p><em>until</em>用法範例：</p>

<pre><code>i = 0
i += 1 until i &gt; 10
puts i
# 輸出 11
</code></pre>

<p><em>loop</em>用法範例：</p>

<pre><code>i = 0
loop do
  i += 1
  break if i &gt; 10 # 中斷迴圈
end
</code></pre>

<p>不過你很快就會發現寫<em>Ruby</em>很少用到<em>while</em>、<em>until</em>、<em>loop</em>，我們會使用迭代器。</p>

<h3 id="section-4">真或假</h3>

<p>記住，只有<code>false</code>和<code>nil</code>是假，其他都為真。</p>

<pre><code>puts "not execute" if nil
puts "not execute" if false

puts "execute" if true # 輸出 execute
puts "execute" if “” # 輸出 execute (和JavaScript不同)
puts "execute" if 0 # 輸出 execute (和C不同)
puts "execute" if 1 # 輸出 execute
puts "execute" if "foo" # 輸出 execute
puts "execute" if Array.new # 輸出 execute
</code></pre>

<h2 id="regular-expressions">正規表示法<em>Regular Expressions</em>
</h2>

<p>與<em>Perl</em>類似的語法，使用<code>=~</code>：</p>

<pre><code># 抓出手機號碼
phone = "123-456-7890"
if phone =~ /(\d{3})-(\d{3})-(\d{4})/
  ext  = $1
  city = $2
  num  = $3
end
</code></pre>

<h2 id="methods">方法定義<em>Methods</em>
</h2>

<p>使用<code>def</code>開頭<code>end</code>結尾來定義一個方法：</p>

<pre><code>def say_hello(name)
  result = "Hi, " + name
  return result
end

puts say_hello('ihower')
# 輸出 Hi, ihower
</code></pre>

<p>方法中的<code>return</code>是可以省略的，<em>Ruby</em>就會回傳最後一行運算的值。上述方法可以改寫成：</p>

<pre><code>def say_hello(name)
  "Hi, " + name
end
</code></pre>

<p>呼叫方法時，括號也是可以省略的，例如：</p>

<pre><code>say_hello 'ihower'
</code></pre>

<p>不過，除了一些方法慣例不加之外(例如<code>puts</code>和<em>Rails</em>中的<code>redirect_to</code>、<code>render</code>方法)，絕大部分的情況加上括號比較無疑義。</p>

<p>我們也可以給參數預設值：</p>

<pre><code>def say_hello(name = "nobody")
  result = "Hi, " + name
  return result
end

puts say_hello
# 輸出 Hi, nobody
</code></pre>

<h2 id="section-5">
<code>?</code>與<code>!</code>的慣例</h2>

<p>方法名稱可以用<code>?</code>或<code>!</code>結尾，前者表示會回傳<em>Boolean</em>值，後者暗示會有某種副作用<em>(side-effect)</em>。範例如下：</p>

<pre><code>array=[2,1,3]

array.empty? # false
array.sort # [1,2,3]

array.inspect # [2,1,3]

array.sort! # [1,2,3]
array.inspect # [1,2,3]
</code></pre>

<h2 id="section-6">物件導向</h2>

<p>物件導向<em>(Object-Oriented Programming)</em>一種將「資料」和「方法」封裝到物件的設計方式，我們定義「類別 Class」，然後依此產生出「物件 Object」，類別可說是物件的樣板。</p>

<p><em>Ruby</em>的類別其實也是一種常數，所以也是大寫開頭，使用<code>new</code>方法可以建立出物件，例如之前所學的字串、陣列和雜湊，也可以用以下方式建立：</p>

<pre><code>color_string = String.new
color_string = "" # 等同

color_array = Array.new
color_array = [] # 等同

color_hash = Hash.new
color_hash = {} # 等同

time  = Time.new # 內建的時間類別
puts time
</code></pre>

<p>來看看如何自定類別：</p>

<pre><code>class Person # 大寫開頭的常數

  def initialize(name) # 建構式
    @name = name # 物件變數
  end

  def say(word)
    puts "#{word}, #{@name}" # 字串相加
  end

end

p1 = Person.new("ihower")
p2 = Person.new("ihover")

p1.say("Hello") # 輸出 Hello, ihower
p2.say("Hello") # 輸出 Hello, ihover
</code></pre>

<blockquote>
  <p>注意到雙引號裡的字串可以使用<code>#{var}</code>來做字串嵌入，相較起用加號<code>+</code>相加字串可以更有效率。</p>
</blockquote>

<p>除了物件方法與物件變數，<em>Ruby</em>也有屬於類別的方法和變數：</p>

<pre><code>class Person

  @@name = “ihower” # 類別變數

  def self.say # 類別方法
    puts @@name
  end

end

Person.say # 輸出 ihower
</code></pre>

<h3 id="section-7">資料封裝</h3>

<p>所有的物件變數(<code>@</code>開頭)、類別變數(<code>@@</code>開頭)，都是封裝在類別內部的，類別外無法存取：</p>

<pre><code>class Person
  def initialize(name)
    @name = name
  end
end

p = Person.new('ihower')
p.name                      # 出現 NoMethodError 錯誤
p.name = 'peny'             # 出現 NoMethodError 錯誤
</code></pre>

<p>為了可以存取到<code>@name</code>，我們必須定義方法：</p>

<pre><code>class Person

  def initialize(name)
    @name = name
  end

  def name
    @name
  end

  def name=(name)
    @name = name
  end
end

p = Person.new('ihower')
=&gt; #&lt;Person:0x007fe9e408b8f0 @name="ihower"&gt;
p.name
=&gt; "ihower"
p.name="peny"
=&gt; "peny"
p.name
=&gt; "peny"
p
=&gt; #&lt;Person:0x007fe9e408b8f0 @name="peny"&gt;
</code></pre>

<h3 id="class">類別<code>Class</code>定義範圍內也可以執行程式</h3>

<p>跟其他程式語言不太一樣，<em>Ruby</em>的類別層級內也可以執行程式，例如以下：</p>

<pre><code>class Demo
  puts "foobar"
end
</code></pre>

<p>當你載入這個類別的時候，就會執行<code>puts "foobar"</code>輸出<em>foobar</em>。會放在這裡的程式，主要的用途是來做<em>Meta-programming</em>。例如，上述定義物件變數的存取方法實在太常見了，因此<em>Ruby</em>提供了<code>attr_accessor</code>、<code>attr_writer</code>、<code>attr_reader</code>類別方法可以直接定義這些方法。上述的程式可以改寫成：</p>

<pre><code>class Person
  attr_accessor :name

  def initialize(name)
    @name = name
  end
end

p = Person.new('ihower')
=&gt; #&lt;Person:0x007fe9e3094410 @name="ihower"&gt;
p.name
=&gt; "ihower"
p.name="peny"
=&gt; "peny"
p.name
=&gt; "peny"
p
=&gt; #&lt;Person:0x007fe9e3094410 @name="peny"&gt;
</code></pre>

<p>這裡的<code>attr_accessor</code>其實就是一個類別方法。</p>

<h3 id="section-8">方法封裝</h3>

<p>類別中的方法預設是<code>public</code>的，宣告<code>private</code>或<code>protected</code>的話，該行以下的方法就會套用：</p>

<pre><code>class MyClass

  def public_method
  end

  private

  def private_method_1
  end

  def private_method_2
  end

  protected

  def protected_method
  end

end
</code></pre>

<p><em>Ruby</em>的<em>private</em>和<em>protected</em>定義和其他程式語言不同，都是可以在整個繼承體系內呼叫。兩著差別在於<em>private</em>只有在物件內部才能呼叫，預設的接收者<em>(receiver)</em>就是物件本身，也就是<em>self</em>。而<em>protected</em>方法除了可以在本身內部呼叫以外，還可以被子類別的物件、或是另一個相同類別的物件呼叫。</p>

<blockquote>
  <p>在物件導向的術語中，<code>object.call_method</code>的意思是<em>object</em>收到執行<em>call_method</em>的指令，也就是<em>object</em>是<em>call_method</em>方法的接受者<em>(receiver)</em>。因此，你甚至可以改寫成<code>object.__send__(:call_method)</code></p>
</blockquote>

<h3 id="class-">Class 繼承</h3>

<p><em>Ruby</em>使用小於<code>&lt;</code>符號代表類別繼承：</p>

<pre><code>class Pet
  attr_accessor :name, :age

  def say(word)
    puts "Say: #{word}"
  end
end

class Cat &lt; Pet
  def say(word)
    puts "Meow~"
    super
  end
end

class Dog &lt; Pet
  def say(word, person)
    puts "Bark at #{person}!"
    super(word)
  end
end

Cat.new.say("Hi")
Dog.new.say("Hi", "ihower")
</code></pre>

<p>輸出</p>

<pre><code>Meow~
Say: Hi
Bark at ihower!
Say: Hi
</code></pre>

<p>這個範例中，<code>Cat</code>和<code>Dog</code>子類別覆寫了<em>Pet say</em>方法，其中的<code>super</code>是用來呼叫被覆寫掉的<em>Pet say</em>方法。另外，沒有括號的<code>super</code>和有括號的<code>super()</code>是有差異的，前者<em>Ruby</em>會自動將所有參數都代進去來呼叫父類別的方法，後者則是自己指定參數。此例中如果<em>Dog say</em>裡只寫<code>super</code>，則會發生<em>wrong number of arguments</em>的錯誤，這是因為<em>Ruby</em>會傳<code>say("Hi", "ihower")</code>給<em>Pet say</em>而發生錯誤。</p>

<h3 id="module">Module</h3>

<p><em>Module</em>是<em>Ruby</em>一個非常好用的功能，它跟<em>Class</em>類別非常相似，你可以在裡面定義方法。只是你不能用<em>new</em>來建立它。它的第一個用途是可以當做<em>Namespace</em>來放一些工具方法：</p>

<pre><code>module MyUtil

  def self.foobar
    puts "foobar"
  end

end

MyUtil.foobar
# 輸出 foobar
</code></pre>

<p>另一個更重要的功能是<em>Mixins</em>，可以將一個<em>Module</em>混入類別之中，這樣這個類別就會擁有此<em>Module</em>的方法。這回讓我們拆成兩個檔案，<em>debug.rb</em>和<em>foobar.rb</em>，然後在<em>foobar.rb</em>中用<code>require</code>來引用<em>debug.rb</em>：</p>

<p>首先是<em>debug.rb</em></p>

<pre><code>module Debug
  def who_am_i?
    puts "#{self.class.name}: #{self.inspect}"
  end
end
</code></pre>

<p>然後是<em>foobar.rb</em></p>

<pre><code>require "./debug"
class Foo
  include Debug # 這個動作叫做 Mixin
end

class Bar
  include Debug
end

f = Foo.new
b = Bar.new
f.who_am_i? # 輸出 Foo: #&lt;Foo:0x00000102829170&gt;
b.who_am_i? # 輸出 Bar: #&lt;Bar:0x00000102825b88&gt;
</code></pre>

<p><em>Ruby</em>使用<em>Module</em>來解決多重繼承的問題，不同類別之間但是擁有相同的方法，就可以改放在<em>Module</em>裡面，然後<code>include</code>它即可。</p>

<h2 id="iterator">迴圈走訪與迭代器<em>Iterator</em>
</h2>

<p>不同於<code>while</code>迴圈用法，<em>Ruby</em>習慣使用迭代器<em>(Iterator)</em>來走訪迴圈，例如<code>each</code>是一個陣列的方法，它會走訪其中的元素，其中的<code>do ... end</code>是<code>each</code>方法的參數，稱作匿名方法<em>(code block)</em>。範例程式如下：</p>

<pre><code>languages = ['Ruby', 'Javascript', 'Perl']
languages.each do |lang|
  puts "I love #{lang}!"
end
# I Love Ruby!
# I Love Javascript!
# I Love Perl!
</code></pre>

<p>其中兩個直線<code>|</code>中間的<em>lang</em>被稱作<em>Block variable</em>區塊變數，每次迭代都會被設定成不同元素。其他迭代器範例如：</p>

<pre><code># 反覆三次
3.times do
  puts 'Good Job!'
end
# Good Job!
# Good Job!
# Good Job!

# 從一數到九
1.upto(9) do |x|
  puts x
end

# 多一個索引區塊變數
languages = ['Ruby', 'Javascript', 'Perl']
languages.each_with_index do |lang, i|
    puts "#{i}, I love #{lang}!"
end
# 0, I Love Ruby!
# 1, I Love Javascript!
# 2, I Love Perl!
</code></pre>

<p><em>(Code block)</em>的形式除了<code>do ... end</code>，也可以改用大括號。通常單行會會用大括號，多行會用<code>do ... end</code>的形式。</p>

<pre><code>3.times { puts "Hello" }
</code></pre>

<p>透過迭代器，我們就比較少用到<code>while</code>、<code>until</code>、<code>for</code>等迴圈語法了。</p>

<h3 id="section-9">其他迭代方式範例</h3>

<pre><code># 迭代並造出另一個陣列
a = ["a", "b", "c", "d"]
b = a.map {|x| x + "!" }
puts b.inspect

# 結果是 ["a!", "b!", "c!", "d!"]

# 找出符合條件的值
b = [1, 2, 3].find_all{ |x| x % 2 == 0 }
b.inspect
# 結果是 [2]

# 迭代並根據條件刪除
a = [51, 101, 256]
a.delete_if {|x| x &gt;= 100 }
# 結果是 [51]

# 客製化排序
[2, 1, 3].sort! { |a, b| b &lt;=&gt; a }
# 結果是 [3, 2, 1]

# 計算總和
(5..10).inject {|sum, n| sum + n }
# 結果是 45

# 找出最長字串find the longest word
longest = ["cat", "sheep", "bear"].inject do |memo, word|
  ( memo.length &gt; word.length ) ? memo : word
end
# 結果是 "sheep"
</code></pre>

<blockquote>
  <p><code>&lt;=&gt;</code>是比較運算子，當兩個數字相等於回傳<code>0</code>，第一個數字較大時回傳<code>1</code>，反之回傳<code>-1</code></p>
</blockquote>

<h3 id="section-10">僅執行一次呼叫</h3>

<p>除了迭代，<em>Code block</em>只會執行一次的特性也很有用，例如用來開啟檔案。往常我們在檔案處理完畢之後，會使用<code>close</code>方法關閉：</p>

<pre><code>file = File.new("testfile", "r")
# ...處理檔案
file.close
</code></pre>

<p>改用<em>Code block</em>語法之後，<em>Ruby</em>就會在<em>Code block</em>結束後自動關檔：</p>

<pre><code>File.open("testfile", "r") do |file|
  # ...處理檔案
end
# 檔案自動關閉
</code></pre>

<p><em>Code block</em>的這個特性不只讓你少打<code>close</code>方法，更可以避免你忘記關閉檔案(不然就語法錯誤了)，也有視覺上縮排的好處。</p>

<h3 id="yield">Yield</h3>

<p>在方法中使用<code>yield</code>可以執行<em>Code block</em>參數：</p>

<pre><code># 定義方法
def call_block
  puts "Start"
  yield
  yield
  puts "End"
end

call_block { puts "Blocks are cool!" }
# 輸出
# "Start"
# "Blocks are cool!"
# "Blocks are cool!"
# "End"
</code></pre>

<h3 id="code-block">帶有參數的<em>Code block</em>
</h3>

<pre><code>def call_block
  yield(1)
  yield(2)
  yield(3)
end

call_block { |i|
  puts "#{i}: Blocks are cool!"
}
# 輸出
# "1: Blocks are cool!"
# "2: Blocks are cool!"
# "3: Blocks are cool!"
</code></pre>

<h3 id="proc-object">Proc object</h3>

<p>可以將<em>Code block</em>明確轉成一個變數：</p>

<pre><code>def call_block(&amp;block)
  block.call(1)
  block.call(2)
  block.call(3)
end

call_block { |i| puts "#{i}: Blocks are cool!" }

# 輸出
# "1: Blocks are cool!"
# "2: Blocks are cool!"
# "3: Blocks are cool!"

# 或是先宣告出 proc object
proc_1 = Proc.new { |i| puts "#{i}: Blocks are cool!" }
proc_2 = lambda { |i| puts "#{i}: Blocks are cool!" }

call_block(&amp;proc_1)
call_block(&amp;proc_2)

# 分別輸出
# "1: Blocks are cool!"
# "2: Blocks are cool!"
# "3: Blocks are cool!"
</code></pre>

<h2 id="section-11">傳遞不定參數</h2>

<pre><code>def my_sum(*val)
  val.inject { |sum, v| sum + v }
end

puts my_sum(1, 2, 3, 4) # val 變數就是 [1, 2, 3, 4]
# 輸出 10
</code></pre>

<p>其中<em>my_sum</em>方法中的<code>val</code>是一個包含所有參數的陣列。</p>

<h2 id="hash-">參數尾巴的<em>Hash</em>可以省略<code>{ }</code>
</h2>

<pre><code>def my_print(a, b, options)
  puts a
  puts b
  puts options[:x]
  puts options[:y]
  puts options[:z]
end

my_print("A", "B", { :x =&gt; 123, :z =&gt; 456 } )
my_print("A", "B", :x =&gt; 123, :z =&gt; 456) # 結果相同
# 輸出 A
# 輸出 B
# 輸出 123
# 輸出 nil
# 輸出 456
</code></pre>

<h2 id="section-12">例外處理</h2>

<p>使用<em>rescue</em>可以將例外救回來：</p>

<pre><code>begin
  puts 10 / 0 # 這會丟出 ZeroDivisionError 的例外錯誤
rescue =&gt; e
  puts e.class # 如果發生例外會執行 rescue 這一段
ensure
  # 無論有沒有發生例外，ensure 這一段都一定會執行
end
# 輸出 ZeroDivisionError
</code></pre>

<p>使用<em>raise</em>可以手動觸發例外錯誤：</p>

<pre><code>raise "Not works!!"
# 丟出一個 RuntimeError

# 自行自定例外物件
class MyException &lt; RuntimeError
end

raise MyException
</code></pre>

<h2 id="metaprogramming">
<em>Metaprogramming</em>用程式寫程式</h2>

<p><em>Metaprogramming</em>是很進階的技巧，這裡示範<code>define_method</code>方法可以動態定義方法：</p>

<pre><code>class Dragon
  define_method(:foo) { puts "bar" }

  ['a', 'b', 'c', 'd', 'e', 'f'].each do |x|
    define_method(x) { puts x }
  end
end

dragon = Dragon.new
dragon.foo # 輸出 bar
dragon.a # 輸出 a
dragon.f # 輸出 f
</code></pre>

<h3 id="introspection">
<em>Introspection</em>反射機制</h3>

<p><em>Ruby</em>擁有許多反射方法，可以動態知道物件的資訊：</p>

<pre><code># 這個物件有什麼方法
Object.methods
=&gt; ["send", "name", "class_eval", "object_id", "new", "singleton_methods", ...]

# 這個物件有這個方法嗎？
Object.respond_to? :name
=&gt; true
</code></pre>

<h2 id="section-13">其他常見慣例</h2>

<pre><code>result ||= a
</code></pre>

<p>如果<code>result</code>是<code>nil</code>或<code>false</code>的話，將<code>a</code>指派給<code>result</code>，如果不是的話，什麼都不做。以上這段程式等同於</p>

<pre><code>result || ( result = a )
</code></pre>

<h2 id="ruby--1">Ruby 應用</h2>

<p>除了本書介紹的<em>Ruby on Rails</em>之外，<em>Ruby</em>也有各式各樣的應用，以下茲舉一些使用<em>Ruby</em>發展的專案：</p>

<ul>
  <li>
<a href="http://www.sinatrarb.com/">Sinatra</a>：輕量級的<em>Web</em>框架</li>
  <li>網頁設計
    <ul>
      <li>
<a href="http://sass-lang.com/">Sass</a>：CSS Pre-Processor</li>
      <li>
<a href="http://lesscss.org/">Less</a>：CSS Pre-Processor</li>
      <li>
<a href="http://compass-style.org/">Compass</a>：CSS 設計框架</li>
      <li>
<a href="http://middlemanapp.com/">Middleman</a>: 靜態網站產生工具</li>
      <li>
<a href="http://jekyllrb.com/">Jekyll</a>: 靜態網站和Blog產生工具</li>
    </ul>
  </li>
  <li>自動化測試
    <ul>
      <li>
<a href="http://cukes.info/">Cucumber</a>：BDD 測試框架</li>
      <li>
<a href="http://watir.com/">Watir</a>：自動化瀏覽器測試工具</li>
    </ul>
  </li>
  <li>DevOps
    <ul>
      <li>
<a href="https://www.getchef.com/">Chef</a>：伺服器部署工具</li>
      <li>
<a href="http://puppetlabs.com/">Puppet</a>：伺服器部署工具</li>
      <li>
<a href="https://www.vagrantup.com/">Vagrant</a>：虛擬機(VM)工具</li>
    </ul>
  </li>
  <li>iOS/Mac
    <ul>
      <li>
<a href="http://cocoapods.org/">CocoaPods</a>：Objective-C 的套件管理工具</li>
      <li>
<a href="http://www.rubymotion.com/">RubyMotion</a> <em>是由</em>Objective-C<em>實作的</em>Ruby<em>，運作在</em>iOS<em>和</em>Mac OS X<em>作業系統上，也可以在</em>App Store*上架。這個平台需要商業收費。</li>
    </ul>
  </li>
  <li>
<a href="http://www.redmine.org/">Redmine</a>：專案管理系統</li>
</ul>


        <p><a href="#">》回到頁首</a></p>
	     </div>
	</div>
</div>

<div class="footer">
<div class="container">
<p>
<a href="https://ihower.tw/rails4/">Ruby on Rails 實戰聖經</a> | Copyright©2014 <a href="https://ihower.tw">Wen-Tien Chang</a>. All Rights Reserved.<br>
除投影片使用<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/tw/">創用 CC 授權</a>釋出，文字及圖片等內容保留所有權利。<br>
本網頁樣式來自 <a href="http://guide.couchdb.org/">CouchDB: The Definitive Guide</a>。<br>
本網頁最後產生時間：29 Jan 2015
</p>
</div>
</div>
</body>
</html>
